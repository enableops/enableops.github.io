"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[701],{7406:function(e){e.exports=JSON.parse('{"blogPosts":[{"id":"argocd-with-public-helm-charts-and-private-git","metadata":{"permalink":"/enableops/enableops.github.io/gh-pages-dev/blog/argocd-with-public-helm-charts-and-private-git","editUrl":"https://github.com/enableops/enableops.github.io/edit/main/blog/blog/2021-11-19-argocd-with-private-git/index.md","source":"@site/blog/2021-11-19-argocd-with-private-git/index.md","title":"ArgoCD with public charts and private values.yaml","description":"Using ArgoCD for proper GitOps is great. You define your workload, put it in VCS, point ArgoCD to it with proper credentials and you\u2019re good. But there is a case, when you\u2019re not the one developing some piece of software, but you do want to store it\u2019s configuration privately.","date":"2021-11-19T00:00:00.000Z","formattedDate":"November 19, 2021","tags":[{"label":"gitops","permalink":"/enableops/enableops.github.io/gh-pages-dev/blog/tags/gitops"}],"readingTime":2.43,"truncated":true,"authors":[{"name":"Dmitry Rozhdestvenskiy","title":"Internal Engineer","url":"https://github.com/yellowmegaman","imageURL":"https://github.com/yellowmegaman.png","key":"yellowmegaman"}],"nextItem":{"title":"What is GitOps? The ArgoCD version","permalink":"/enableops/enableops.github.io/gh-pages-dev/blog/what-is-gitops-argocd"}},"content":"Using ArgoCD for proper GitOps is great. You define your workload, put it in VCS, point ArgoCD to it with proper credentials and you\u2019re good. But there is a case, when you\u2019re not the one developing some piece of software, but you do want to store it\u2019s configuration privately.\\n\\n\x3c!--truncate--\x3e\\n\\nWe\u2019re talking about public helm charts. Copying public chart to your repo is not something you would love to do and it will bring lot of hassle \u2013 you will end up in situation when chart was updated by creators, and you need to sync or update.\\n\\nBut configuration is sensitive data, so you want to keep it private. This is some part of functionality not yet covered by ArgoCD itself, because you can\u2019t specify public repo and private repo for values.yaml at the same time.\\n\\nThankfully ArgoCD is extendable with plugins.\\n\\n## Traefik plugin configuration and credentials\\n\\nFirst things first, we need to create ArgoCD plugin and add it to our installation\\n\\nThis is the configuration block for both our private repo with values.yaml and plugin:\\n\\n```yaml title=\\"values.yaml\\"\\n---\\napiVersion: v1\\nkind: ConfigMap\\nmetadata:\\n  name: argocd-cm\\n  namespace: argocd\\ndata:\\n  repositories: |\\n    - url: git@github.com:yellowmegaman/somerepo\\n      sshPrivateKeySecret:\\n        name: some-repo-key\\n        key: sshPrivateKey\\n  configManagementPlugins: |\\n    - name: helm-resolver\\n      init:\\n        command: [bash, -c]\\n        args: [\\"helm repo add $REPO_NAME $REPO_URL && helm repo update\\"]\\n      generate:\\n        command: [bash, -c]\\n        args: [\\"helm template --include-crds -n $ARGOCD_APP_NAMESPACE $COMMAND $ARGOCD_APP_NAME $REPO_NAME/$CHART_NAME --version $CHART_VERSION\\"]\\n```\\n\\nAdd ssh private key to kubernetes secret:\\n\\n```shell\\nkubectl -n argocd create secret generic some-repo-key \\\\\\\\\\n        --from-file=sshPrivateKey=$HOME/.ssh/id_ed25519\\n```\\n\\n## Application configuration\\n\\nIn `yellowmegaman/somerepo` repo we have a folder `values` with file `traefik-values.yaml` with following contents:\\n\\n```yaml title=\\"traefik-values.yaml\\"\\ndeployment:\\n  kind: DaemonSet\\nadditionalArguments:\\n  - \\"--api=true\\"\\n  - \\"--api.insecure=true\\"\\n  - \\"--accesslog=true\\"\\n  - \\"--providers.kubernetesIngress.ingressClass=traefik-cert-manager\\"\\n```\\n\\nWe want to use it with official Traefik helm chart.\\n\\nLet\u2019s verify the installation:\\n![Screenshot of installation in ArgoCD](./first-installation-argocd.png)\\n\\nDefine application using helm-resolver plugin in app.yaml:\\n\\n```yaml title=\\"app.yaml\\"\\n---\\napiVersion: argoproj.io/v1alpha1\\nkind: Application\\nmetadata:\\n  name: traefik-private-values\\n  namespace: argocd\\nspec:\\n  destination:\\n    namespace: traefik\\n    server: <https://555.555.555.555>\\n  project: default\\n  syncPolicy:\\n    automated:\\n      prune: true\\n      selfHeal: true\\n    syncOptions:\\n      - Validate=true\\n      - CreateNamespace=true\\n  source:\\n    path: values\\n    plugin:\\n      env:\\n        - name:  REPO_NAME\\n          value: \\"traefik\\"\\n        - name:  REPO_URL\\n          value: \\"<https://helm.traefik.io/traefik>\\"\\n        - name:  CHART_NAME\\n          value: \\"traefik\\"\\n        - name:  CHART_VERSION\\n          value: \\"10.6.2\\"\\n        - name:  COMMAND\\n          value: \\"--values traefik-values.yaml\\"\\n      name: helm-resolver\\n    repoURL: git@github.com/yellowmegaman/somerepo\\n```\\n\\nApply application to local cluster:\\n\\n```shell\\nkubectl -n argocd apply -f app.yaml\\n```\\n\\nVerify installation in ArgoCD:\\n![Screenshot of installation in ArgoCD](./final-installation-argocd.png)\\n\\nOne of the main changes to the configuration in our `traefik-values.yaml` files was about changing deployment type to DaemonSet, let\u2019s verify that this change was included in the deployment:\\n\\n```shell \\nk -n traefik get ds\\n```\\n\\n```\\n$ k -n traefik get ds\\nNAME                     DESIRED   CURRENT   READY   UP-TO-DATE   AVAILABLE   NODE SELECTOR   AGE\\ntraefik-private-values   1         1         1       1            1           <none>          2m38s\\n```\\n\\n## Conclusion\\n\\nNow that we have everything in place, we can change official chart version or our privately stored values to trigger an update. Woot!"},{"id":"what-is-gitops-argocd","metadata":{"permalink":"/enableops/enableops.github.io/gh-pages-dev/blog/what-is-gitops-argocd","editUrl":"https://github.com/enableops/enableops.github.io/edit/main/blog/blog/2021-11-18-what-is-gitops-argocd/index.md","source":"@site/blog/2021-11-18-what-is-gitops-argocd/index.md","title":"What is GitOps? The ArgoCD version","description":"GitOps is an approach. It\u2019s not a product, not a tool. You can deliver software updates to the cloud, to Tesla car or hobby project based on Raspberry Pi with the help of GitOps.","date":"2021-11-18T00:00:00.000Z","formattedDate":"November 18, 2021","tags":[{"label":"gitops","permalink":"/enableops/enableops.github.io/gh-pages-dev/blog/tags/gitops"}],"readingTime":4.745,"truncated":true,"authors":[{"name":"Dmitry Rozhdestvenskiy","title":"Internal Engineer","url":"https://github.com/yellowmegaman","imageURL":"https://github.com/yellowmegaman.png","key":"yellowmegaman"}],"prevItem":{"title":"ArgoCD with public charts and private values.yaml","permalink":"/enableops/enableops.github.io/gh-pages-dev/blog/argocd-with-public-helm-charts-and-private-git"},"nextItem":{"title":"Getting started with Google Cloud & Terraform","permalink":"/enableops/enableops.github.io/gh-pages-dev/blog/getting-started-with-google-cloud-terraform"}},"content":"GitOps is an approach. It\u2019s not a product, not a tool. You can deliver software updates to the cloud, to Tesla car or hobby project based on Raspberry Pi with the help of GitOps.\\n\\n\x3c!--truncate--\x3e\\n\\nMain thing to note here \u2013 unlike how operations were carried out in the past, with GitOps we can be sure not to miss *how* some operation was performed, because everything is stored (in git) now.\\n\\n## Moving parts\\n\\n* application or automation code\\n* VCS to store this code in\\n* GitOps component which is performing an update\\n* access to the environment which needs to be updated\\n\\nGeneral scheme is quite simple \u2013 you change something, update is got deployed automatically somewhere. Forget about old-school uploading of artefacts to remote host and running some commands afterwards.\\n![Moving parts](./moving-parts.png)\\n\\n## Benefits\\n\\n* Deployment change is peer-reviewed\\n* Full audit-log of actions performed against environment are stored in git and versioned\\n* No need for personal access to environments, only the GitOps component has rights to perform update, on the behalf of programmatic means access like ServiceAccount\\n* Easy to track changes from last deployment\\n* Easy rollback to the previous version\\n* Nice web UI \ud83d\ude01\\n\\n## ArgoCD\\n\\nLet\u2019s install ArgoCD and connect it to GKE cluster\\n\\n```shell title=\\"terminal\\"\\nhelm repo add argo <https://argoproj.github.io/argo-helm>\\nhelm repo update\\nhelm install argocd --create-namespace \\\\\\\\\\n                      --namespace argocd \\\\\\\\\\n                      --set dex.enabled=false argo/argo-cd\\n```\\n\\nFor this example we\u2019re skipping ArgoCD DEX component, because installation is performed locally on docker for desktop kubernetes.\\n\\nNow we can get the password for admin user:\\n```shell title=\\"terminal\\"\\nkubectl -n argocd get secret argocd-initial-admin-secret \\\\\\\\\\n        -o jsonpath=\\"{.data.password}\\" | base64 -d\\n```\\n\\nPort-forward ArgoCD server to access it locally:\\n```shell title=\\"terminal\\"\\nkubectl port-forward service/argocd-server -n argocd 8080:443\\n```\\n\\nNow we can install ArgoCD CLI to add remove clusters. We also do need to authenticate ourselves against our local install. Use admin password from above:\\n```shell\\n$ brew install argocd\\n$ argocd login 127.0.0.1:8080\\nWARNING: server certificate had error: x509: cannot validate certificate for 127.0.0.1 because it doesn\'t contain any IP SANs. Proceed insecurely (y/n)? y\\nUsername: admin\\nPassword:\\n\'admin:login\' logged in successfully\\nContext \'127.0.0.1:8080\' updated\\n$ argocd cluster list\\nSERVER                          NAME        VERSION  STATUS   MESSAGE\\n<https://kubernetes.default.svc>  in-cluster           Unknown  Cluster has no application and not being monitored.\\n```\\n\\nWe can see now that ArgoCD is authenticated and shows the cluster which it is deployed into.\\n\\nNow let\'s add some remote GKE cluster from Google Cloud:\\n```shell\\n$ gcloud container clusters get-credentials production --zone us-central1-f --project someproject-1337\\nFetching cluster endpoint and auth data.\\nkubeconfig entry generated for production.\\n$ kubectl config get-contexts\\nCURRENT   NAME                                          CLUSTER                                         AUTHINFO                                     NAMESPACE\\n          docker-desktop                                docker-desktop                                  docker-desktop\\n*         gke_someproject-1337_us-central1-f_production gke_someproject-1337_us-central1-f_production   gke_someproject-1337_us-central1-f_production\\n\\n\\n$ export GOOGLE_CREDENTIALS=terraform.json # we specify our ServiceAccount key\\n$ argocd cluster add gke_someproject-1337_us-central1-f_production\\nWARNING: This will create a service account `argocd-manager` on the cluster referenced by context `gke_someproject-1337_us-central1-f_argocd` with full cluster level admin privileges. Do you want to continue [y/N]? y\\nINFO[0004] ClusterRole \\"argocd-manager-role\\" created\\nINFO[0005] ClusterRoleBinding \\"argocd-manager-role-binding\\" updated\\nCluster \'https://555.555.555.555\' added\\n\\n$ argocd cluster list\\nSERVER                          NAME                                             VERSION  STATUS   MESSAGE\\nhttps://555.555.555.555         gke_someproject-1337_us-central1-f_production    Unknown  Cluster has no application and not being monitored.\\nhttps://kubernetes.default.svc  in-cluster                                       Unknown  Cluster has no application and not being monitored.\\n$\\n```\\n\\nWhat happened here?\\n- we got credentials for GKE cluster with the help of gcloud\\n- looked at available kubectl contexts\\n- exported ServiceAccount key location as env variable\\n- added cluster to ArgoCD\\n- checked that it was added properly\\n\\n:::tip\\n\\nImportant thing to note here. We\'re using local credentials only once, after that ArgoCD creates it\'s own k8s ServiceAccount in target cluster, this way authentication JWT token is not expiring, as it is with gcloud.\\n\\n:::\\n\\n\\n## Deployment\\n\\nNow we can deploy our app. We gonna skip VCS part for this example, it requires additional configuration for ArgoCD private repos. You can check it out [here](https://argo-cd.readthedocs.io/en/release-1.8/user-guide/private-repositories/).\\n\\nSave this example Traefik deployment manifest to disk:\\n```yaml title=\\"Application-traefik.yaml\\"\\n---\\napiVersion: argoproj.io/v1alpha1\\nkind: Application\\nmetadata:\\n  name: traefik\\nspec:\\n  destination:\\n    namespace: traefik\\n    server: <https://555.555.555.555>\\n  project: default\\n  syncPolicy:\\n    automated:\\n      prune: true\\n      selfHeal: true\\n    syncOptions:\\n      - Validate=true\\n      - CreateNamespace=true\\n  source:\\n    path: \'\'\\n    repoURL: <https://helm.traefik.io/traefik>\\n    chart: \\"traefik\\"\\n    targetRevision: \\"10.6.2\\"\\n    helm:\\n      parameters:\\n      - name: service.type\\n        value: \\"ClusterIP\\"\\n```\\n\\nNow we are applying it locally to our docker-desktop cluster where ArgoCD is resided. It, in turn will sync this workload to remote GKE cluster\\n\\n```shell\\n$ kubectl -n argocd apply -f Application-traefik.yaml\\n$ kubectl config use-context gke_someproject-1337_us-central1-f_production\\n$ kubectl -n traefik get po\\nNAME                       READY   STATUS    RESTARTS   AGE\\ntraefik-65c68d8dd7-qzmzp   0/1     Running   0          7s\\n$ \\n```\\n\\n\\nLet\u2019s check the web UI of our ArgoCD.\\n\\nOpen https://127.0.0.1:8080 and log in. Certificate will be invalid, but that\u2019s OK for local testing installation. Provide admin password obtained in previous step.\\n![Screenshot of app in ArgoCD](./app-view.png)\\n\\nApplication details:\\n![Screenshot of app details in ArgoCD](./app-details.png)\\n\\nNow we have firm connection between ArgoCD GitOps component and GKE cluster, woot!\\n\\n## Git part\\n\\nWe can now proceed with configuration of private repos to pull changes from git, or apply changes locally.\\n\\nWe need to place repository secret (e.g. private key) in kubernetes secrets in argocd namespace.\\n\\nAfter that we can apply private repo configuration:\\n\\n```shell\\nargocd repo add git@github.com:argoproj/argocd-example-apps.git \\\\\\\\\\n                --ssh-private-key-path ~/.ssh/id_rsa\\n```\\n\\nDefine the app:\\n\\n```yaml\\n---\\napiVersion: argoproj.io/v1alpha1\\nkind: Application\\nmetadata:\\n  name: guestbook\\n  namespace: argocd\\nspec:\\n  destination:\\n    namespace: guestbook\\n    server: <https://555.555.555.555>\\n  project: default\\n  syncPolicy:\\n    automated:\\n      prune: true\\n      selfHeal: true\\n    syncOptions:\\n      - Validate=true\\n      - CreateNamespace=true\\n  source:\\n    path: \\"guestbook\\"\\n    repoURL: <https://github.com/argoproj/argocd-example-apps>\\n    targetRevision: HEAD\\n```\\n\\nCheck target cluster:\\n\\n```shell\\n$ kubectl -n guestbook get po\\nNAME                            READY   STATUS    RESTARTS   AGE\\nguestbook-ui-85985d774c-ttn2p   1/1     Running   0          23s\\n$ \\n```\\n\\nFrom now on you can deploy applications from your private git repo. When you modify the files in `targetRevision` location, ArgoCD will update your cluster. Woot!"},{"id":"getting-started-with-google-cloud-terraform","metadata":{"permalink":"/enableops/enableops.github.io/gh-pages-dev/blog/getting-started-with-google-cloud-terraform","editUrl":"https://github.com/enableops/enableops.github.io/edit/main/blog/blog/2021-11-17-getting-started-with-google-cloud-terraform/index.md","source":"@site/blog/2021-11-17-getting-started-with-google-cloud-terraform/index.md","title":"Getting started with Google Cloud & Terraform","description":"Thousands of startups start to use cloud every day and it\u2019s truly a great way to start building your first infrastructure for new project.","date":"2021-11-17T00:00:00.000Z","formattedDate":"November 17, 2021","tags":[{"label":"getting_started","permalink":"/enableops/enableops.github.io/gh-pages-dev/blog/tags/getting-started"}],"readingTime":3.935,"truncated":true,"authors":[{"name":"Dmitry Rozhdestvenskiy","title":"Internal Engineer","url":"https://github.com/yellowmegaman","imageURL":"https://github.com/yellowmegaman.png","key":"yellowmegaman"}],"prevItem":{"title":"What is GitOps? The ArgoCD version","permalink":"/enableops/enableops.github.io/gh-pages-dev/blog/what-is-gitops-argocd"}},"content":"Thousands of startups start to use cloud every day and it\u2019s truly a great way to start building your first infrastructure for new project.\\n\\n\x3c!--truncate--\x3e\\n\\nMost of the time people that are delegated with such tasks are very excited and also are quite limited in time. But the cloud is ever-expanding system with millions of features and some not really evident defaults. It is really hard to understand everything from first go, if you are not some 10 YOE professional.\\n\\nBut the most important thing \u2013 it\u2019s incredibly hard to repeat all actions after something complex has already been set up. This is the moment when IaC (Infrastructure as code) comes in handy! And the best choice for that nowadays is Hashicorp Terraform. It has big community, lot\u2019s of official modules and it is very stable and extendable.\\n\\n## Start using Google Cloud\\n\\nWhenever you are using personal account, or Google Workspace was already set up, actions are basically identical. You can head over to http://cloud.google.com/ to activate your cloud account. You may also want to activate your free trial, usually a message appears at the top of the page or in the center.\\n![Google Cloud](./google-cloud.png)\\n\\nIf you chose to proceed with this great offer, or decided to skip it for now, you are just few steps away from getting proper IaC going with your new cloud account.\\n\\n## Download and install gcloud (Google Cloud SDK)\\n\\nMac users can user [brew](https://brew.sh/) for that, otherwise you can follow download instructions [here](https://cloud.google.com/sdk/docs/install).\\n\\nBrew installation example:\\n\\n```shell\\nbrew install google-cloud-sdk\\n```\\n\\nAfter installation is complete it\u2019s time to authenticate your gcloud cli\\n\\n```shell\\ngcloud auth login\\n```\\n\\nNew tab in your browser will open to choose the account to use with gcloud. Important note here \u2013 you need to choose the proper account which was used to activate your new Google Cloud.\\n![Google Cloud Sign In](./google-cloud-signin.png)\\n\\nNow that we have gcloud authenticated, we should set the project id. Project id can be found on main Dashboard page of google cloud.\\n![Google Cloud Project Info](./google-cloud-project.png)\\n\\nNow that we have that id, let\u2019s set it for gcloud and verify our newly added auth:\\n\\n```shell\\n$ gcloud config set project someproject-1337\\nUpdated property [core/project].\\nyellowmegaman@Dmitrys-MacBook-Air ~ % gcloud auth list\\n  Credentialed Accounts\\nACTIVE  ACCOUNT\\n*       someone@somedomain.tld\\nTo set the active account, run:\\n    $ gcloud config set account `ACCOUNT`\\n$\\n```\\nAwesome!\\n\\n## Creating custom role and ServiceAccount for terraform\\n\\nTerraform requires a way to interact with any cloud or service. With Google Cloud the most preferred way is ServiceAccount which is granted some roles to perform actions.\\n\\nFirst we create the role. We want to have a role that is permitted to interact with container clusters (GKE), cloud storage buckets (GCS), and create/update/delete ServiceAccounts. You can always add more permissions, or remove them.\\n\\nSave this yaml code to your disk, like `terraform-Role.yaml`\\n\\n```yaml title=\\"terraform-Role.yaml\\"\\n---\\ntitle: terraform\\nstage: GA\\ndescription: terraform IaC role\\nincludedPermissions:\\n  - compute.instanceGroupManagers.get\\n  - container.clusters.create\\n  - container.clusters.delete\\n  - container.clusters.get\\n  - container.clusters.getCredentials\\n  - container.nodes.get\\n  - container.nodes.list\\n  - container.operations.get\\n  - iam.serviceAccounts.create\\n  - iam.serviceAccounts.delete\\n  - iam.serviceAccounts.get\\n  - iam.serviceAccounts.getAccessToken\\n  - iam.serviceAccounts.list\\n  - iam.serviceAccounts.update\\n  - storage.buckets.create\\n  - storage.buckets.delete\\n  - storage.buckets.get\\n  - storage.objects.create\\n  - storage.objects.delete\\n  - storage.objects.get\\n  - storage.objects.getIamPolicy\\n  - storage.objects.list\\n  - storage.objects.setIamPolicy\\n  - storage.objects.update\\n```\\n\\nNow we can create the role (replace `<project_id>` with your value):\\n\\n```shell\\ngcloud iam roles create \\"terraform\\" --project=\\"<project_id>\\" \\\\\\\\\\n                                    --file=terraform-Role.yaml\\n```\\n\\nLet\u2019s create terraform ServiceAccount and couple of role bindings (replace `<project_id>` with your value):\\n\\n```shell\\n$ gcloud iam service-accounts create \\"terraform\\" \\\\\\\\\\n                --description=\\"Terraform IaC service account\\" \\\\\\\\\\n                --display-name=\\"terraform\\"\\n$ gcloud projects add-iam-policy-binding \\"<project_id>\\" \\\\\\\\\\n   --member=\\"serviceAccount:terraform@<project_id>.iam.gserviceaccount.com\\" \\\\\\\\\\n   --role=\\"projects/<project_id>/roles/terraform\\"\\n$ gcloud projects add-iam-policy-binding \\"<project_id>\\" \\\\\\\\\\n   --member=\\"serviceAccount:terraform@<project_id>.iam.gserviceaccount.com\\" \\\\\\\\\\n   --role=\\"roles/iam.serviceAccountUser\\"\\n$ gcloud projects add-iam-policy-binding \\"<project_id>\\" \\\\\\\\\\n   --member=\\"serviceAccount:terraform@<project_id>.iam.gserviceaccount.com\\" \\\\\\\\\\n   --role=\\"roles/container.admin\\"\\n```\\n\\nNow we can head over to [IAM & Admin](https://console.cloud.google.com/iam-admin/iam) in Google Cloud to verify the results:\\n![Google Cloud IAM & Admin](./google-cloud-iam.png)\\n\\n\\n## Creating the ServiceAccount key\\n\\nNow that we have a ServiceAccount with proper roles attached, we need to obtain ServiceAccount key to provide it to terraform. Let\u2019s create one (replace `<project_id>` with your value):\\n\\n```shell\\ngcloud iam service-accounts keys create terraform.json \\\\\\\\\\n    --iam-account=terraform@<project_id>.iam.gserviceaccount.com\\n```\\n\\nAfter running this command you will have ServiceAccount json key that can be used for IaC with terraform and for many other services that do work with Google Cloud.\\n\\nTo use it with terraform you can just export env variable:\\n\\n```shell\\nexport GOOGLE_CREDENTIALS=<path_to_your_key.json>\\n```\\n\\nWhat the benefits of using IaC from the start?\\n\\n* solid backup of configuration of all you infrastructure parts\\n* audit log of actions (if infra code is managed in VCS)\\n* predictable state of infrastructure\\n* hand-picked permissions, not just `Owner` role assigned to terraform as seen in many companies\\n* better understanding what\u2019s happening, instead of clicking random things on Web UI"}]}')}}]);